# Конспект №7: RAII, finally.
## Теоретический материал.
Идиома RAII берёт своё начало в языке C++ и заключается в том, что некоторый ресурс захватывается в конструкторе объекта, и освобождается в его деструкторе. А поскольку деструктор локальных объектов вызывается автоматически при выходе из метода не зависимо от причины, то использование этой идиомы является самым простыми и эффективным способом написания сопровождаемого C++ кода, безопасного с точки зрения исключений.
RAII может использоваться для любых разделяемых объектов или ресурсов:
- для выделения памяти.
- для открытия файлов или устройств.
- для критических секций и мьютексов.

Дополнительно:
- [Что такое мьютекс?](https://ru.wikipedia.org/wiki/Мьютекс)
- [Что такое критическая секция?](https://ru.wikipedia.org/wiki/Критическая_секция)

Важный случай использования RAII - "умные указатели", классы, инкапсулирующие владение памятью. Например, в стандартной библиотеке C++ для этого есть auto_ptr или unique_ptr.

Основной смысл RAII заключается в автоматическом гарантированном освобождении ресурсов, не только при завершении программы и вызове деструктора, но и при выбрасывании исключения. 
Например: ресурсы, создающиеся по ссылке, освобождаются автоматически при покидании зоны видимости, а те, что создаются по указателю, нужно освобождать вручную. При этом в самом объекте должен быть предусмотрен запрет копирования объекта, чтобы данный объект гарантированно являлся единстенным ресурсом в памяти.

Как раз-таки по причине наличия идиомы RAII, C++ не поддерживает **finally** блоков.
## Примеры использования.
Пример №1: абстрактное определение.

    Tobj A;                 // ссылка на стек - освобождается автоматически
    Tobj* B = new Tobj;     // выделяется память - освобождать вручную
    
Пример №2: применение RAII для динамической памяти.

    class Stack {
        int *A;
        int A_size;
    public:
        Stack(int _size):A_size(_size) {
           A = new int[_size];
        }
        ~Stack() {
            delete [] A;
        }
        Stack& operator=(const Stack &right) {
            delete [] A;
            A_size = right.A_size;
            A = new int[A_size];
            for(int i = 0; i < A_size; i++)
                A[i] = right.A[i];
        }
    };
    void stack_use() {
        Stack a(50), b(10);
        a = b;
    }
    int main() {
        cout << "Hello world!" << endl;
        stack_use();
        return 0;
    }
    
- [Что такое RAII?(1)](https://www.youtube.com/watch?v=4hZLYpCJZyE&ab_channel=НОУИНТУИТ)
- [Что такое RAII?(2)](https://foxford.ru/wiki/informatika/raii-poluchenie-resursa-est-initsializatsiya)
- [Что такое RAII?(3)](https://ru.wikipedia.org/wiki/Получение_ресурса_есть_инициализация)
- [Почему С++ не поддерживается finally](https://coderoad.ru/161177/Поддерживает-ли-C-блоки-finally-И-что-это-за-RAII-о-котором-я-все-время-слышу)
